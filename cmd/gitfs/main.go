// gitfs command line tool, for generating binary conetent of the used filesystems.
package main

import (
	"context"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"text/template"

	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"

	"github.com/posener/gitfs"
	"github.com/posener/gitfs/internal/binfs"
)

var (
	out = flag.String("out", "gitfs.go", "Output file")
	pkg = flag.String("pkg", "", "Package name for output file (default is the package name of current directory)")
)

func init() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), usage)
		flag.PrintDefaults()
	}
}

func main() {
	flag.Parse()

	if len(flag.Args()) == 0 {
		log.Fatal("At least one file pattern should be provided.")
	}

	// fix flags.
	var err error
	*out, err = getOut(*out)
	if err != nil {
		log.Fatalf("Invalid out flag: %s", err)
	}
	*pkg, err = getPkg(*pkg, *out)
	if err != nil {
		log.Fatalf("Invalid: pkg must be provided if output is not a Go package: %s", err)
	}

	f, err := os.Create(*out)
	if err != nil {
		log.Fatalf("Failed creating file %q: %s", *out, err)
	}
	defer f.Close()

	err = generate(f)
	if err != nil {
		defer os.Remove(*out)
		log.Fatalf("Failed generating filesystem: %s", err)
	}
}

func generate(w io.Writer) error {
	binaries, err := binfs.LoadBinaries(flag.Args(), provider)
	if err != nil {
		return err
	}
	if len(binaries) == 0 {
		return errors.New("did not found any calls for gitfs.New")
	}

	return binFileTmpl.Execute(w, struct {
		Package  string
		Binaries map[string]string
		Version  int
	}{
		Package:  *pkg,
		Binaries: binaries,
		Version:  binfs.EncodeVersion,
	})
}

func provider(project string) (http.FileSystem, error) {
	return gitfs.New(context.Background(), project, gitfs.OptPrefetch(true))
}

// getOut fixes out variable if it points to a directory or a file
// non-existing directory.
func getOut(out string) (string, error) {
	if out == "" {
		return "gitfs.go", nil
	}
	st, err := os.Stat(out)
	if err != nil {
		// File does not exists, make sure it is a file in current directory
		// or other existing directory.
		dir, _ := filepath.Split(out)
		if dir == "" {
			// The user chose to create a local file.
			return out, nil
		}
		// The user creates a file in directory `dir`.
		st, err := os.Stat(dir)
		if err != nil {
			return "", errors.Errorf("output directory %q not found: %s", dir, err)
		}
		if !st.IsDir() {
			return "", errors.Errorf("output directory %q is not a directory", dir)
		}
		return out, nil
	}
	if st.IsDir() {
		// If the given output is a directory, add filename 'gitfs.go'.
		out = filepath.Join(out, "gitfs.go")
	}
	return out, nil
}

// getPkg fixes the package name according to the given name in the
// command line or the package of the output file.
func getPkg(pkg, out string) (string, error) {
	if pkg != "" {
		return pkg, nil
	}
	outDir, _ := filepath.Split(out)
	if outDir == "" {
		outDir = "."
	}
	pkgs, err := packages.Load(nil, outDir)
	if err != nil {
		return "", errors.Errorf("failed loading package in %q: %s", outDir, err)
	}
	if len(pkgs) == 0 {
		return "", errors.Errorf("could not load package in %q", outDir)
	}
	return pkgs[0].Name, nil
}

// binFileTmpl is the template for the generated file.
var binFileTmpl = template.Must(template.New("template").Parse(`
// Code generated by gitfs; DO NOT EDIT
package {{.Package}}

import "github.com/posener/gitfs/bin"

func init() {
	{{ range $project, $bin := .Binaries -}}
	bin.Register("{{$project}}", {{$.Version}}, "{{$bin}}")
	{{ end }}
}
`))

const usage = `gitfs packs filesystems into Go binary for github.com/posener/gitfs library.

Usage:

	gitfs <flags> <patterns>

The command will traverses all Go files in the given patterns and
looks for 'gitfs.New' calls. For each of these calls, it downloads the
specified project. All the projects are then saved into a single
go file (default gitfs.go).
When this file is compiled to a Go binary, the projects are automatically
loaded from the packed version instead of remote repository.

Note:

The calls for 'gitfs.New' must contain an explicit string represented
project name. With the current implementation, the project can't be
inferred from a variable or a constant.


Example:

To pack all usage of gitfs filesystems in the current project, run from
the root of the project the following command:

	gitfs ./...

Flags:

`
